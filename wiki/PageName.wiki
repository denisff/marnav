#summary Requirements

= Overview =

== Computing Platform ==

Linux 2.6.x running on MiniATX or other low power form factor.  Best if no fans were required and no rotating storage were required. Windows XP / Mac compatibility would be nice. Multiple screens should be accommodated.

== Interfaces ==
 * Selected NMEA 0183 devices
 * Selected NMEA 2000 devices
[http://gpsd.berlios.de/ gpsd] has a bad reputation.  One option is to write our own GPS code for NMEA 0183, but we need to support other 0183 devices and NMEA 2000 devices as well.  We should check out [http://folks.o-hand.com/iain/gypsy/ gypsy].

Like gpsd, the Gypsy daemon program is started at system boot. It connects to the D-Bus system bus and waits. When a client application tells it to connect to a GPS device it connects and parses the NMEA sentences generated by the GPS device and it emits signals onto the system bus. Applications can choose to listen to whatever signals they are interested in and ignore the rest. Gypsy emits fine grained signals over d-bus so that applications which are only interested in the location signals do not have to know about the course signals or the satellite signals, for example.

D-bus means that the applications / applets need to be on a single machine (an ICE would not have this restriction.)

== GUI ==
The UI shown in the [http://www.marnav.info/blog/index.php/archives/2008/05/13/foss-navsoft-tease/ marnav.info blog] is not what I would recommend going forward... (but the glade file I used to make the software shown on the blog is [http://code.google.com/p/marnav/source/browse/trunk/src/marnav.glade here], if you want to examine it) I think it is important to instead follow the UI of the Gimp, with a separate toolbox window, and separate viewport windows.  I share this file with you so you can see what a complete glade file looks like.  There are references to Python callbacks in this glade file, so you won't be able to view it in a running program until the callbacks  are removed. Don't bother doing that ... this UI isn't worth fixing.

I suggest that the Glade designer be used to prototype an initial UI layout.  Beware: the Glade designer is a bit tempramental, however each release is a step forward.  Implementing the entire project in C++ would make sense; I am also open to using other typed languages like Java and Scala.  Python/Jython is great for integration and scripting, and meshes with C/C++ really well.  Java 6 now contains scripting features.

Anyway, if we start with a 100% Glade mockup we can get an idea of what to build, and discuss the implementation language.

The next step would be to create some custom GTK components.  C++ would be best for this, I think.  The Gimp uses miniature GTK buttons - not sure how they do that.  I think the default GTK widgets are rather clunky.  It takes time to craft nice widgets, so it would make sense to examine The Gimp's custom widget code.

A major issue will be to decide on the GPS feed mechanism.  Various open source alternatives exist.  This decision should support NMEA 0183 (via serial port and USB) as well as NMEA 2000.  The high level architectural design will probably be affected by this choice.

== License ==
Dual licensing makes sense; free for non-commercial use, and something else for commercial use.  An attribution style license (MIT, BSD or Apache) or LGPL seems OK for non-commercial use.

If we choice very permissive license we can't take code from other GPL projects, unless those are packaged separately (IE separately loaded dynamic library code.)